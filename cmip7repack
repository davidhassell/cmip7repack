#!/bin/bash

# ====================================================================
#
# cmip7repack
#
# ====================================================================
vn=0.2
date="2025-10-03"

iam=$0
iam_path=$(which $iam)
iam=$(basename $iam)

synopsis="$iam [-d size] [-h] [-o] [-v] [-x] [-z n] FILE [FILE ...]"
usage="USAGE: $synopsis"

helpFunction()
{
    (
	cat << EOF
.TH $iam 1 $vn $date $iam
.
.SH NAME
.
$iam - repack CMIP7 netCDF-4 datasets
.
.
.
.SH SYNOPSIS
.
$synopsis
.
.
.
.SH DESCRIPTION
.
For each netCDF-4 FILE, $iam will

- Collate all of the internal file metadata to a contiguous block at
  the start of the file.

- Rechunk the time coordinate variable, if it exists, to have a single
  compressed chunk.

- Rechunk the time_bounds coordinate variable, if it exists, to have a
  single compressed chunk.

- OPTIONAL. Rechunk the data variable to have a given uncompressed
  chunk size.
.
.
.
.SH OPTIONS
.
.TP
.B -d size
Rechunk the data variable (the variable named by the variable_id
global attribute) to have the given uncompressed chunk size (in
bytes). The chunk shape will only be changed along the leading
dimension of the data variable (which is usually the time axis), and
only if a) the original uncompressed chunk size is smaller than the
new value, and b) the original number of chunk elements along the
leading dimension is 1. If either of these conditions is not met then
the data variable will not be rechunked. Rechunked data is
de-interlaced with the HDF5 shuffle filter and compressed with zlib
level 4.
.
.TP
.B -h
Display this help and exit.
.
.TP
.B -o
Overwrite each original file with its repacked version, if the
repacking was successful. By default, a new file with the suffix
'_cmip7repack' is created for each input file.
.
.TP
.B -v
Print version number and exit.
.
.TP
.B -x
Do a dry run. Show the repacking command for each file, but do not run
it.
.
.TP
.B -z n
Specify the deflate compression level (between 1 and 9, default 4) for
rechunked variables.
.
.
.
.SH EXAMPLES

Repack a file, replacing the original file with its repacked version:

  $ cmip7repack -o file.nc
  cmip7repack: Version 0.2 at /bin/cmip7repack
  cmip7repack: h5repack: Version 1.14.3 at /bin/h5repack

  cmip7repack: date-time: Fri  3 Oct 09:56:03 BST 2025
  cmip7repack: preparing to repack 'file.nc'
  cmip7repack: repack command: h5repack --metadata_block_size=877832  -f /time:SHUF -f /time:GZIP=4 -f /time:FLET -l /time:CHUNK=6000 -f /time_bounds:SHUF -f /time_bounds:GZIP=4 -f /time_bounds:FLET -l /time_bounds:CHUNK=6000x2 file.nc file.nc_cmip7repack
  cmip7repack: running repack command (may take some time ...)
  cmip7repack: successfully created 'file.nc_cmip7repack' in 13 seconds

  cmip7repack: Total of 1 files (297046606 bytes) repacked in 13 seconds (22849738 B/s) to total size 296728324 bytes (0% smaller than input files)
  $
.
.
.SH AUTHOR
Written by David Hassell and Ezequiel Cimadevilla.
.
.
.SH REPORTING BUGS
Report any bugs to
<https://github.com/davidhassell/cmip7repack/issues>
.
.
.SH COPYRIGHT
Copyright Â© 2025 License BSD 3-Clause
<https://opensource.org/license/bsd-3-clause>. This is free software:
you are free to change and redistribute it. There is NO WARRANTY, to
the extent permitted by law.
.
.
.SH SEE ALSO
h5repack(1)
EOF
    ) | man -r "Manual page $iam(1) ?ltline %lt?L/%L.:" -l - 
	  
    exit 0
}

# --------------------------------------------------------------------
# Parse command line options
# --------------------------------------------------------------------
if [ $# -eq 0 ]; then
    echo $usage
    exit 1
fi

# Defaults
gzip=4
size=false
version=false
overwrite=false
dry_run=false

while getopts ":d:hotvxz:" opt
do
    case $opt in
      d) size=$OPTARG 
         echo $size | grep -q "^[0-9][0-9]*$" 
         if [ $? -ne 0 ]; then
             echo "Option -d requires a numerical argument" >&2
             echo "$usage" >&2
             exit 2
         fi ;;
      h) helpFunction ;;
      o) overwrite=true ;;
      v) version=true ;;
      x) dry_run=true ;;
      z) gzip=$OPTARG
         echo $gzip | grep -q "^[1-9]$" 
         if [ $? -ne 0 ]; then
             echo "Option -z requires a numerical argument between 1 and 9" >&2
             echo "$usage" >&2
             exit 2
         fi ;;
      \?) echo -e "Invalid option: -$OPTARG\n$usage" >&2
          exit 2 ;;
      :) echo "Option -$OPTARG requires an argument" >&2
         echo "$usage" >&2
         exit 2 ;;
    esac
done
shift $((OPTIND -1))

echo "$iam: Version $vn at $iam_path"
if [ "$version" = true ]; then
    exit 0
fi

# --------------------------------------------------------------------
# Check that the HDF5 commands are available
# --------------------------------------------------------------------
h5repack_path=$(which h5repack)
if [ $? -ne 0 ]; then
    echo "$iam: ERROR: Must install h5repack to use $iam"
    exit 3
fi
echo "$iam: $(h5repack -V) at $h5repack_path"

h5stat_path=$(which h5stat)
if [ $? -ne 0 ]; then
    echo "$iam: ERROR: Must install h5stat to use $iam"
    exit 3
fi

h5dump_path=$(which h5dump)
if [ $? -ne 0 ]; then
    echo "$iam: ERROR: Must install h5dump to use $iam"
    exit 3
fi

# --------------------------------------------------------------------
# Loop over input files
# --------------------------------------------------------------------
start0=`date +%s`
totalsizein=0  # Total size of input files
totalsizeout=0  # Total size of output files
N=0  # Number of repacked input files
for file in $@
do
    start_time=`date +%s`

    echo ""
    echo "$iam: date-time: $(date)"
    echo "$iam: preparing to repack '$file'"

    if [ ! -e $file ]; then
        echo "iam: file does not exist"
        continue
    fi

    # Get the input file size
    filesize=$(wc -c < "$file")
    totalsizein=$(($totalsizein+$filesize))

    # ----------------------------------------------------------------
    # Get the h5repack --metadata_block_size option
    #
    # For instance:
    #
    #  From h5stat -S output:
    #    '  File metadata: 40988486 bytes'
    #  get:
    #    --metadata_block_size=40988486
    # ----------------------------------------------------------------
    metadata=$(h5stat -S $file \
		   | sed -n -E 's/^[[:space:]]*File metadata:[[:space:]]*([0-9]+).*/\1/p')
    if [ "$metadata" != "" ]; then
        metadata="--metadata_block_size=$metadata"
    fi

    # ----------------------------------------------------------------
    # Get the time bounds variable using CF bounds attribute.
    #
    # For instance:
    #
    #   From h5dump output:
    #       ATTRIBUTE "bounds" {
    #          DATATYPE  H5T_STRING {
    #             STRSIZE 10;
    #             STRPAD H5T_STR_NULLTERM;
    #             CSET H5T_CSET_ASCII;
    #             CTYPE H5T_C_S1;
    #          }
    #          DATASPACE  SCALAR
    #          DATA {
    #          (0): "time_bnds"
    #          }
    #       }
    #
    #   get:
    #     time_bnds
    # ----------------------------------------------------------------
    bounds=$(h5dump -A -d time $file | awk '$1=="ATTRIBUTE" && $2=="\"bounds\""{bnds=1}bnds && $1=="(0):"{v=$NF; gsub("\"", "", v); bnds=0}END{print v}')
    bounds="/${bounds}"
    
    # ----------------------------------------------------------------
    # Get the h5repack -l and -f options for the time variables
    #
    # For instance:
    #
    #   From h5dump output:
    #     '   DATASPACE  SIMPLE { ( 6000 ) / ( H5S_UNLIMITED ) }'
    #   get:
    #     -l /time:CHUNK=6000 -f /time:GZIP=4
    #   
    #   From h5dump output:
    #     '   DATASPACE  SIMPLE { ( 6000, 2 ) / ( H5S_UNLIMITED, 2 ) }'
    #   get:
    #     -l /time_bounds:CHUNK=6000x2 -f /time_bounds:GZIP=4
    # ----------------------------------------------------------------
    time=""
    for variable in "/time" "${bounds}"
    do
    	CHUNK=$(h5dump --dataset ${variable} --header $file 2>/dev/null \
    		    | grep "DATASPACE  SIMPLE" -m 1 \
    		    | sed -E 's/.*\(\s*([0-9, ]+)\s*\).*/\1/; s/[[:space:]]+//g; s/,/x/g')
    	if [ "$CHUNK" != "" ]; then
	    time="$time -f ${variable}:SHUF -f ${variable}:GZIP=$gzip -f ${variable}:FLET"
    	    time="$time -l ${variable}:CHUNK=$CHUNK"
    	fi
    done
    
    # ----------------------------------------------------------------
    # Get the h5repack -l and -f options for the data variable.
    #
    # For instance:
    #
    #   -l /uas:CHUNK=50x143x144 -f /uas:SHUF -f /uas:GZIP=4 -f /uas:FLET
    # ----------------------------------------------------------------
    data=""
    if [ "$size" != false ]; then
        # Find the data variable name
        variable=$(h5dump --attribute variable_id $file 2>/dev/null \
                       | grep "(0)" -m 1 \
                       | sed -n 's/.*"\(\w*\)"/\1/p')

        if [ "$variable" != "" ]; then
            variable="/$variable"

            # Find the chunk shape
            CHUNK=""
    	    chunks=$(h5dump --dataset ${variable} --properties --header $file 2>/dev/null \
    			 | grep "CHUNKED (" -m 1 \
    			 | sed -n 's/.*(\(.*\)).*/\1/p' \
    			 | sed 's/,\s*/ /g')
    	    chunks=($chunks)

	    # Attempt to define a new data variable chunk shape, but
	    # only if the leading element of the existing chunk shape
	    # is 1.
	    #
            # For instance:
            #
	    #       1 144 192 -> attempt to rechunk
	    #      37 144 192 -> do not attempt to rechunk
	    if [ "${chunks[0]}" -eq 1 ]; then
                # Number of data dimensions
                ndim=${#chunks[@]}

                # Find the word size, in bytes, of the data values.
		datatype=$(h5dump --dataset $variable --header $file 2>/dev/null \
                                 | grep "DATATYPE" -m 1)
		if [ "$(echo $datatype | grep 32)" != "" ]; then
                    wordsize=4
		else
                    wordsize=8
		fi

                # Iteratively reduce the size of first chunk dimension, so
                # that the final chunk size is less than or equal to the
                # given size.
                chunks[0]=$(( $size / $wordsize ))
                n=1
                while [ $n -lt $ndim ]
                do
                    chunks[0]=$(( ${chunks[0]} / ${chunks[$n]} ))
                    n=$(( $n + 1 ))
                done
                
                # Create an h5repack CHUNK value for the data variable
                CHUNK=${chunks[0]}
                if [ $CHUNK -le 1 ]; then
		    # No need to rechunk if the leading chunk-shape
		    # element is now 0 or 1
                    CHUNK=""
                else
		    # Leading chunk-shape element is now > 1, so we
		    # can define a new chunk shape.
                    n=1
                    while [ $n -lt $ndim ]
                    do
                        CHUNK=${CHUNK}x${chunks[$n]}
                        n=$(( $n + 1 ))
                    done
                fi
            else
                echo "$iam: not rechunking data variable $variable with existing chunk shape (${chunks[@]})"
            fi
        fi
	
        if [ "$CHUNK" != "" ]; then
	    data="-f ${variable}:SHUF -f ${variable}:GZIP=$gzip -f ${variable}:FLET"
            data="$data -l ${variable}:CHUNK=$CHUNK"
        fi	
    fi
    
    if [ "$metadata$time$data" = "" ]; then
        echo "$iam: can't repack $file: Couldn't find time, time bounds or data variables, nor the metadata block size"
        echo "$iam: file $file is unchanged"	
        continue	    
    fi

    # Still here? Define the repacking command
    repacked_file=${file}_cmip7repack
    command="h5repack $metadata $time $data $file $repacked_file"
    echo "$iam: repack command: $command"
    if [ "$dry_run" = true ]; then
        echo "$iam: dry-run: not repacking"
        continue
    fi
    
    # Still here? Run the repacking command
    echo "$iam: running repack command (may take some time ...)"
    h5repack $metadata $time $data $file $repacked_file
    if [ $? -eq 0 ]; then	
        # Successfully repacked
        end_time=`date +%s`
        N=$(( $N + 1 ))
        echo "$iam: successfully created '$repacked_file' in $(($end_time - $start_time)) seconds"

	# Get the output file size
	filesize=$(wc -c < "$repacked_file")
	totalsizeout=$(($totalsizeout + $filesize))

        if [ "$overwrite" = true ]; then
            # Overwrite original file with repacked file
            mv_output=$(mv -v $repacked_file $file)
            echo "$iam: $mv_output"
        fi
    else
        echo "$iam: FAILED to repack $file"
        echo "$iam: file $file is unchanged"
    fi
done
end0=`date +%s`    

if [ "$dry_run" = false ]; then
    # Get the repack rate
    totaltime=$(($end0 - $start0))
    if [ $totaltime -gt 0 ]; then
        rate="($(($totalsizein / $totaltime )) B/s)"
    else
        rate=""
    fi

    pcdiff=$(( (100 * ($totalsizein - $totalsizeout))/$totalsizein ))
    if [ $pcdiff -ge 0 ]; then
        pcdiff="(${pcdiff}% smaller than input files)"
    else
	pcdiff=$(($pcdiff * -1))
        pcdiff="(${pcdiff}% larger than input files)"
    fi

    echo ""
    echo "$iam: Total of $N files ($totalsizein bytes) repacked in $totaltime seconds $rate to total size $totalsizeout bytes $pcdiff"
fi
